## Game of life

rust + typescript implementation of [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).


#### requirement

- rust tool chain, including `rustup`, `rustc`, and `cargo`. installation instruction [here](https://www.rust-lang.org/tools/install)

- `wasm-pack`, for building, testing, and publishing Rust WebAssembly. installation instruction [here](https://rustwasm.github.io/wasm-pack/installer/) 

- `nodejs` with `npm`, we will use it to install and run a JavaScript bundler and development server.

#### projet structure

Let take a look at the project contents:

```
wasm/
├── Cargo.toml
├── README.md
└── src
    ├── lib.rs
    └── utils.rs
└── www/
    ├── bootstrap.js
    ├── index.html
    ├── index.js
    ├── package.json
    └── webpack.config.js
```

`wasm/Cargo.toml`
The Cargo.toml file specifies dependencies and metadata for `cargo`, Rust's package manager and build tool. This one comes pre-configured with a `wasm-bindgen` dependency.

`wasm/src/lib.rs`
The `src/lib.rs` file is the root of the Rust crate that we are compiling to WebAssembly. This file contains the main logic of  [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life). It uses `wasm-bindgen` to interface with JavaScript.

`wasm/src/utils.rs`
The `src/utils.rs` module provides common utilities to make working with Rust compiled to WebAssembly easier.

`wasm/www/index.js`
The `index.js` is the main entry point for our Web page's JavaScript. It imports the `wasm-game-of-life` package. this package will be create when we are going to compile the rust projet with `wasm`


`wasm/www/index.html`
This is the root HTML file for the Web page. It load the `bootstrap.js` file a tiny wrapper around `index.js`. It also content the `<canvas>` HTML element we are going to use to display the [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) ui.


#### building projet

First, we are going to use the command `wasm-pack` to orchestrate the build of the rust project targeting the `Webassembly` target.

Inside the project directory:
```
wasm-pack build
```

This build will generate a `node` module inside the `pkg` directory. 

```
pkg/
├── package.json
├── README.md
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.d.ts
└── wasm_game_of_life.js
```

As you can see, this package contains:

`wasm_game_of_life_bg.wasm`
the WebAssembly binary that is generated by the Rust compiler from our Rust sources. It contains the compiled-to-wasm versions of all of our Rust functions and data

`wasm_game_of_life.js`
The .js file is generated by `wasm-bindgen` and contains JavaScript glue for importing DOM and JavaScript functions into Rust and exposing a nice API to the WebAssembly functions to JavaScript.

This package `wwasm_game_of_life`  generate by the compilaition will be imported in the `wwww` web project. As you can see in the `www/package.json` file.

```javascript
{
  "name": "create-wasm-app",
  "version": "0.1.0",
  "description": "create an app to consume rust-generated wasm packages",
  "main": "index.js",
  ....
  "dependencies": {                    
    "wasm-game-of-life": "file:../pkg"
  },
  ....
}
```

Next step, it is to build the `wwww` web project via `webpack`.

Inside the `wwww` directory, install the dependencies first.
```
npm install --dev
```

Then build the project.
```
npm run build
```

#### run 

Once the build step done, we can finaly run the project.

Inside the `wwww` directory, start the dev server:
```
npm start 
```

Then open the url [localhost:8080](http://localhost:8080) on your favorite browser to display the ui. 


#### canvas

the project use a `<canvas>` element to draw the state of the game. Let take a brief look how to use javascript api to draw graphic element.

First, we need to instanciate 2D context.

```typescript
let canvas = document.getElementById('game-of-life-canvas') as HTMLCanvasElement;
let ctx = ctx = canvas.getContext("2d");
```

To draw of the  `<canvas>` element, we need first to start a new path with method `CanvasRenderingContext2D.beginPath()` and then close the path with the method  `CanvasRenderingContext2D.stroke()`.

```typescript
ctx.beginPath();
//TODO: draw some line, rectangle ...
ctx.stroke(); 
```

For this exercise, we need to draw to thing: a *line* for the grid and a *rectangle*  for aliving cell.

To draw a line:
```typescript
// set line color
ctx.strokeStyle = "#CCCCCC";

// move to starting point (in pixel).
ctx.moveTo(0, 0); 

// adds a straight line to the current sub-path by connecting the sub-path's 
// last point to the specified (x, y) coordinates.
ctx.lineTo(200, 100);  
```

To draw a rectangle:
```typescript
// set rectangle color
ctx.fillStyle = "#CCCCCC";

// The fillRect() method draws a filled rectangle whose starting point is at (x, y) and whose size is specified by width and height.
ctx.fillRect(x,y, width, height);
```


Last thing, we need to do is to run the animation loop.

```typescript
 function renderLoop() {
    
        // TODO - compute next state of the game - ie alive cell
        // TODO - draw aliving cell on canvas. 

        let animationId = requestAnimationFrame(() => {
            renderLoop();
        });
  
    }
```

